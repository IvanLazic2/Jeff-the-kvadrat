//https://www.youtube.com/watch?v=Ouza_4SsbLc
//https://codepen.io/rickyjw/pen/qrjmdz
//https://editor.p5js.org/Coulomb1/sketches/ajYsnHRW2
//https://www.coursera.org/lecture/nand2tetris2/unit-3-10-graphics-optimization-hHNmi
//https://classes.engineering.wustl.edu/cse365/demo_program.php
//https://arieljannai.gitlab.io/Nand2TetrisBitmapEditor/
//https://github.com/ErikUmble/nand2tetris/tree/main/DinoAdventure

//https://www.redblobgames.com/pathfinding/a-star/introduction.html
//https://www.youtube.com/watch?v=5DhCoqoPmzs

//https://github.com/IshankGulati/Image-Processing-Mini-projects/blob/master/Astar%20Search/pathPlanning.py




// IDEJA: sortirat platforme po x koordinati
// IDEJA2: brojac koji broji kolko ih je izaslo iz ekrana. kolko ih je izaslo tolko mogu stvorit novih tako da starima promijenim koordinate.
//         ako nijedna nije izasla iz ekrana, a treba se pokazat novi, sam stvorim novu platformu




class Game
{
    field int Direction;
    field Character Character;
    field int ScreenWidth;
    field int MoveAreaWidth;
    field int ScreenMiddle;
    field int LeftBorder;
    field int RightBorder;

    field int PlatformsCount;
    field int ObstaclesCount;
    field int EnemiesCount;
    field int CollectablesCount;
    field int BulletsCount;
    //field int sections_num;
    //field int section_width;

    field Array Platforms;
    field Array Obstacles;
    field Array Enemies;
    field Array Collectables;
    field Array Bullets;
    //field Array sections;

    //field Section curr_section;
    //field Section last_section;
    //field int curr_section_index;
    //field int last_section_index;
    //field Array curr_Platforms;
    //field int curr_PlatformsCount;

    field Array div4lookup;

    field Level3 Level;


    //field Array curr_Obstacles;
    //field int curr_ObstaclesCount;




    field int GameDelay;

    field int timer3;
    field int timer6;
    field int timer100;

    field Array map;
    field int mapWidth;
    field int mapHeight;

    field int WorldOffset;



    field Pathfinding pathfinding;

    field int pathFindingTimer;
    field int pathFindingDelay;


    
    


    constructor Game new()
    {
        var int i;
        var int j;
        var int value;

        let Direction = 0;

        let ScreenWidth = 32;
        let MoveAreaWidth = 5; // 5
        let ScreenMiddle = 16;
        let LeftBorder = ScreenMiddle - MoveAreaWidth;
        let RightBorder = ScreenMiddle + MoveAreaWidth;

        let Level = Level3.new();
        let map = Level.getMap();
        let mapWidth = Level.getMapWidth();
        let mapHeight = Level.getMapHeight();
        do Map.setWidth(mapWidth);
        do Map.setHeight(mapHeight);
        do Map.setMap(map);

        //do Pathfinding.setMap(map);

        //do Output.printInt(Map.getValue(0, 15));

        let Character = Level.getCharacter();

        let PlatformsCount = Level.getPlatformsCount();
        let ObstaclesCount = Level.getObstaclesCount();
        let EnemiesCount = Level.getEnemiesCount();
        let CollectablesCount = Level.getCollectablesCount();

        let Platforms = Level.getPlatforms();
        let Obstacles = Level.getObstacles();
        let Enemies = Level.getEnemies();
        let Collectables = Level.getCollectables();

        let div4lookup = Array.new(mapWidth);
        let i = 0;
        while (i < mapWidth)
        {
            let div4lookup[i] = i / 4;
            let i = i + 1;
        }

        //let last_section = sections[get_curr_section_index()];



        let GameDelay = 20;

        let timer3 = 3;
        let timer6 = 6;
        let timer100 = 100;

        let WorldOffset = 0;

        do GetBulletsCount();
        let Bullets = Array.new(BulletsCount);
        do GetBullets();


        do DrawAllPlatforms();
        do DrawAllCollectables();

        
        let pathfinding = Pathfinding.new(map, mapWidth, mapHeight);

        //do pathfinding.search(1, 1, 6, 6);
        
        
        let pathFindingDelay = 100;

 

        return this;
    }


    method void start()
    {
        var char key;
        var bool exit;
        var int i;
        var int j;
        var int temp;
        var Platform platform;
        var int value;


        let exit = false;

        //do Screen.drawLine(0, 255-80, 511, 255-80);

        while (~exit)
        {
            

            let key = Keyboard.keyPressed();

            if (key = 0)
            {
                let Direction = 0;
            }
            else { if (key = 131)
            {
                do Character.Jump();
            }
            else { if (key = 81) 
            {
                let exit = true;
            }
            else { if (key = 130) 
            {
                let Direction = 1;
            }
            else { if (key = 132) 
            {
                let Direction = 2;
            }
            else { if (key = 32)
            {
                do Character.Shoot(WorldOffset);
            }}}}}}
            


            
            do Move();
            do Sys.wait(GameDelay);
            


            do Character.RedrawPlatforms(map, mapWidth, mapHeight, WorldOffset);

            do DoAllEnemyActions();

            do CheckEnemyAndCharacterCollision();

            do CheckAllBullets();

            do CheckAllBulletCollisions();

            do CheckCollectableAndCharacterCollision();


            

            do CheckTimers();



            do DecrementTimers();

            



        }

        return;
    }


    // GAME TIMERS
    method void CheckTimers()
    {
        if (timer6 < 1)
        {
            //do RedrawLastSection();
            do RedrawAllObstacles();

            let timer6 = 6;
        }

        if (timer100 < 1)
        {
            //do Screen.drawLine(0, 255-80, 511, 255-80);

            let timer100 = 100;
        }

        if (pathFindingTimer < 1)
        {
            //do pathfinding.search(0, 0, 6, 6);
            //do Output.printString("nig");
            let pathFindingTimer = pathFindingDelay;
        }

        do Character.CheckTimers();
        do CheckAllEnemyTimers();

        return;
    }

    
    method void DecrementTimers()
    {
        let timer3 = timer3 - 1;
        let timer6 = timer6 - 1;
        let timer100 = timer100 - 1;

        let pathFindingTimer = pathFindingTimer - 1;

        do Character.DecrementTimers();
        do DecrementAllEnemyTimers();

        return;
    }

    // ENEMY TIMERS
    method void CheckAllEnemyTimers()
    {
        var Enemy enemy;
        var int i;

        while (i < EnemiesCount)
        {
            let enemy = Enemies[i];
            do enemy.CheckTimers();
            let i = i + 1;
        }

        return;
    }

    method void DecrementAllEnemyTimers()
    {
        var Enemy enemy;
        var int i;

        while (i < EnemiesCount)
        {
            let enemy = Enemies[i];
            do enemy.DecrementTimers();
            let i = i + 1;
        }

        return;
    }





    method void DrawAllPlatforms()
    {
        var Platform platform;
        var int i;

        

        while (i < PlatformsCount)
        {
            let platform = Platforms[i];
            do platform.Draw();
            let i = i + 1;
        }

        return;
    }

    method void DrawAllCollectables()
    {
        var int i;
        var Collectable collectable;

        while (i < CollectablesCount)
        {
            let collectable = Collectables[i];
            do collectable.Draw(true);
            let i = i + 1;
        }

        return;
    }

    method void RedrawAllObstacles()
    {
        var Obstacle obstacle;
        var int i;

        

        if (Character.get_should_draw_last_obstacle())
        {
            while (i < ObstaclesCount)
            {
                let obstacle = Obstacles[i];

                do obstacle.Draw();

                let i = i + 1;
            }
            do Character.set_should_draw_last_obstacle(false);
        }

        return;
    }




    method void DoAllEnemyActions()
    {
        var Enemy enemy;
        var int i;

        while (i < EnemiesCount)
        {
            let enemy = Enemies[i];
            do enemy.DoActions(map, mapWidth, mapHeight, WorldOffset, Character.get_x(), Character.get_y());
            let i = i + 1;
        }

        return;
    }

    method void CheckEnemyAndCharacterCollision()
    {
        var int i;
        var Enemy enemy;
        var bool collided_sides;
        var bool collided_top;

        while (i < EnemiesCount)
        {
            let enemy = Enemies[i];

            if (enemy.getIsAlive())
            {
                let collided_sides = Collision.IsCharacterCollidedWithEnemySides(Character.get_x(), Character.get_y(), Character.getWidth(), Character.getHeight(), enemy.get_x(), enemy.get_y(), enemy.getWidth(), enemy.getHeight());
                let collided_top = Collision.IsCharacterCollidedWithEnemyTop(Character.get_x(), Character.get_y(), Character.getWidth(), Character.getHeight(), enemy.get_x(), enemy.get_y(), enemy.getWidth(), enemy.getHeight());

                if (collided_top)
                {
                    if (enemy.getIsDamageOnSquish())
                    {
                        do Character.Respawn();
                        do Character.TakeDamage();
                    }   
                    else
                    {
                        do enemy.Die();
                    }
                }
                else { if (collided_sides)
                {
                    do Character.Respawn();
                    do Character.TakeDamage();
                }}
            }

            
        

            let i = i + 1;
        }

        return;
    }


    method void CheckAllBullets()
    {
        var int i;
        var Enemy enemy;

        do Character.CheckBullets(map, mapWidth, mapHeight, WorldOffset);

        while (i < EnemiesCount)
        {
            let enemy = Enemies[i];
            do enemy.CheckBullets(map, mapWidth, mapHeight, WorldOffset);
            let i = i + 1;
        }

        return;
    }

    method void GetBulletsCount()
    {
        var int i;
        var int count;
        var Enemy enemy;

        let count = Character.getBulletsCount();

        while (i < EnemiesCount)
        {
            let enemy = Enemies[i];
            let count = count + enemy.getBulletsCount();
            let i = i + 1;
        }

        let BulletsCount = count;

        return;
    }

    method void GetBullets()
    {
        var int i;
        var int j;
        var Array bullets;
        var Enemy enemy;
        var int arrSize;

        let bullets = Character.getBullets();

        while (i < Character.getBulletsCount())
        {
            let Bullets[i] = bullets[i];
            let i = i + 1;
        }

        let arrSize = Character.getBulletsCount();

        let i = 0;
        while (i < EnemiesCount)
        {
            let enemy = Enemies[i];
            let bullets = enemy.getBullets();

            while (j < enemy.getBulletsCount())
            {
                let Bullets[arrSize + j] = bullets[j];

                let j = j + 1;
            }

            let arrSize = arrSize + enemy.getBulletsCount();

            let i = i + 1;
        }

        return;
    }

    method void CheckAllBulletCollisions()
    {
        var int i;
        var int j;
        var Enemy enemy;
        var Bullet bullet;

        while (i < BulletsCount)
        {
            let bullet = Bullets[i];

            if (Collision.IsBulletCollidedWithEntity(Character.get_x(), Character.get_y(), Character.getWidth(), Character.getHeight(), bullet.getX(), bullet.getY()))
            {
                do bullet.setCollided(true);
                do Character.Respawn();
                do Character.TakeDamage();
            }

            while (j < EnemiesCount)
            {
                let enemy = Enemies[j];

                if (enemy.getIsAlive())
                {
                    if (Collision.IsBulletCollidedWithEntity(enemy.get_x(), enemy.get_y(), enemy.getWidth(), enemy.getHeight(), bullet.getX(), bullet.getY()))
                    {
                        do bullet.setCollided(true);
                        do enemy.Die();
                    }
                }

                let j = j + 1;
            }

            let i = i + 1;
        }       

        return;
    }

    // ideja: na pocetku skenirat cijeli ekran i iscrtat sve, onda svaki puta zapamtit x, x + width i y koordinate od objekta koji se treba scrollat
    //        i gledat samo granice ekrana (prvi i zadnji stupac, sve zavisi kako se scrolla)

    // ideja2: spremat te objekte (klase GameObject koja ima x, y, w i h) u array velicine 512 i spremat je li na nekom indeksu pojle zauzeto
    //         u drugo polje koje sadrzi 512 bool-ova koji govore jeli mjesto zauzeto ili ne

    method void CheckCollectableAndCharacterCollision()
    {
        var int i;
        var Collectable collectable;

        while (i < CollectablesCount)
        {
            let collectable = Collectables[i];

            if ((-1 < collectable.getX()) & (collectable.getX() < 32) & collectable.getIsAvailable())
            {
                if (Collision.IsBulletCollidedWithEntity(Character.get_x(), Character.get_y(), Character.getWidth(), Character.getHeight(), collectable.getX(), collectable.getY()))
                {
                    do Output.printString("bling");

                    if (collectable.getType() = 0)
                    {
                        do Character.addCoin();
                    }   
                    else
                    {
                        do Character.addLife();
                    }

                    do collectable.setIsAvailable(false);
                }
            }   

            

            let i = i + 1;
        }

        return;
    }






















    method void ScrollLeft()
    {
        var int i;
        var Platform platform;
        var Obstacle obstacle;
        var Enemy enemy;
        var Collectable collectable;

        

        let WorldOffset = WorldOffset + 1;
        do Character.increment_absolute_x(1);

        let i = 0;
        while (i < EnemiesCount)
        {
            let enemy = Enemies[i];
            do enemy.ScrollLeft();

            let i = i + 1;
        }

        let i = 0;
        while (i < CollectablesCount)
        {
            let collectable = Collectables[i];
            do collectable.ScrollLeft();

            let i = i + 1;
        }

        while (i < ObstaclesCount)
        {
            let obstacle = Obstacles[i];
            do obstacle.ClearScrollLeft();

            let i = i + 1;
        }

        let i = 0;
        while (i < PlatformsCount)
        {
            let platform = Platforms[i];
            do platform.ClearScrollLeft();

            let i = i + 1;
        }

        let i = 0;
        while (i < ObstaclesCount)
        {
            let obstacle = Obstacles[i];
            do obstacle.DrawScrollLeft();

            let i = i + 1;
        }

        let i = 0;
        while (i < PlatformsCount)
        {
            let platform = Platforms[i];
            do platform.DrawScrollLeft();

            let i = i + 1;
        }


        return;
    }

    method void ScrollRight()
    {
        var int i;
        var Platform platform;
        var Obstacle obstacle;
        var Enemy enemy;
        var Collectable collectable;

        let WorldOffset = WorldOffset - 1;
        do Character.increment_absolute_x(-1);

        let i = 0;
        while (i < EnemiesCount)
        {
            let enemy = Enemies[i];
            do enemy.ScrollRight();

            let i = i + 1;
        }

        let i = 0;
        while (i < CollectablesCount)
        {
            let collectable = Collectables[i];
            do collectable.ScrollRight();

            let i = i + 1;
        }

        while (i < ObstaclesCount)
        {
            let obstacle = Obstacles[i];
            do obstacle.ClearScrollRight();

            let i = i + 1;
        }

        let i = 0;
        while (i < PlatformsCount)
        {
            let platform = Platforms[i];
            do platform.ClearScrollRight();

            let i = i + 1;
        }

        let i = 0;
        while (i < ObstaclesCount)
        {
            let obstacle = Obstacles[i];
            do obstacle.DrawScrollRight();

            let i = i + 1;
        }

        let i = 0;
        while (i < PlatformsCount)
        {
            let platform = Platforms[i];
            do platform.DrawScrollRight();

            let i = i + 1;
        }

        return;
    }

    method void Move()
    {
        var int x;
        var int abs_x;
        
        let x = Character.get_x();
        let abs_x = Character.get_absolute_x();

        do Character.check_gravity2(map, mapWidth, mapHeight, WorldOffset);
        do Character.check_collision_obstacles2(map, mapWidth, mapHeight);

        if (Direction = 1) 
        {
            do Character.set_draw_character_left(true);

            if (~Character.check_left_collision_platforms2(map, mapWidth, mapHeight, WorldOffset))
            {
                // nesto s apsolutnom vrijednosti izmedju x i pocetka mape?
                if (abs_x - ScreenMiddle + MoveAreaWidth > 0)
                {
                    if (x > LeftBorder)
                    {
                        do Character.MoveLeft();
                    }
                    else
                    {
                        do ScrollRight();
                    }
                }
                else
                {
                    do Character.MoveLeft();
                }
            }
        }
        if (Direction = 2)
        {
            do Character.set_draw_character_left(false);

            if (~Character.check_right_collision_platforms2(map, mapWidth, mapHeight, WorldOffset))
            {
                if (abs_x + ScreenMiddle - MoveAreaWidth < mapWidth)
                {
                    if (x < RightBorder)
                    {   
                        do Character.MoveRight();
                    }
                    else
                    {
                        do ScrollLeft();
                    }
                }
                else
                {
                    do Character.MoveRight();
                }
            }
        }
        
        return;
    }
}
    