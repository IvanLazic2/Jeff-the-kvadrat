//https://www.youtube.com/watch?v=Ouza_4SsbLc
//https://codepen.io/rickyjw/pen/qrjmdz
//https://editor.p5js.org/Coulomb1/sketches/ajYsnHRW2
//https://www.coursera.org/lecture/nand2tetris2/unit-3-10-graphics-optimization-hHNmi
//https://classes.engineering.wustl.edu/cse365/demo_program.php
//https://arieljannai.gitlab.io/Nand2TetrisBitmapEditor/
//https://github.com/ErikUmble/nand2tetris/tree/main/DinoAdventure





// IDEJA: sortirat platforme po x koordinati
// IDEJA2: brojac koji broji kolko ih je izaslo iz ekrana. kolko ih je izaslo tolko mogu stvorit novih tako da starima promijenim koordinate.
//         ako nijedna nije izasla iz ekrana, a treba se pokazat novi, sam stvorim novu platformu




class Game
{
    field int direction;
    field Character character;
    field int world_offset;
    field int screen_width;
    field int move_area_width;
    field int screen_middle;
    field int left_border;
    field int right_border;

    field int platforms_num;
    field int sections_num;
    field int section_width;

    field Array sections;

    field Array div4lookup;

    field Level3 level;

    field int level_width;

    


    constructor Game new()
    {
        var int i;

        let direction = 0;

        let screen_width = 32;
        let world_offset = 0;
        let move_area_width = 5;
        let screen_middle = 16;
        let left_border = screen_middle - move_area_width;
        let right_border = screen_middle + move_area_width;

        let level = Level3.new();

        let level_width = level.get_level_width();
        let character = level.get_character();
        let platforms_num = level.get_platforms_num();
        //let platform_section_sizes = level.get_platform_section_sizes();
        let sections_num = level.get_sections_num();
        let section_width = level.get_section_width();
        let sections = level.get_sections();

        //let section1 = platform_sections[0];
        //let section1size = platform_section_sizes[0];

        let div4lookup = Array.new(32);
        let i = 0;
        while (i < 32)
        {
            let div4lookup[i] = i / 4;
            let i = i + 1;
        }

        return this;
    }

    method int get_curr_section_index()
    {
        return div4lookup[character.get_x()];
    }

    method void start()
    {
        var char key;
        var bool exit;
        var int i;
        var Platform plat_temp;
        var int curr_section_index;
        var Array curr_section;
        var int curr_section_size;
        var Section section;


        let exit = false;

        //do Screen.drawLine(0, 255-80, 511, 255-80);

        while (~exit)
        {
            let key = Keyboard.keyPressed();

            if (key = 0)
            {
                let direction = 0;
            }
            else { if (key = 131)
            {
                do character.Jump();
            }
            else { if (key = 81) 
            {
                let exit = true;
            }
            else { if (key = 130) 
            {
                let direction = 1;
            }
            else { if (key = 132) 
            {
                let direction = 2;
            }}}}}
            
            do move();
            do Sys.wait(40); // 50
            





            //let curr_section_index = character.get_curr_section_index();
            //let curr_section = platform_sections[curr_section_index];
            //let curr_section_size = platform_section_sizes[curr_section_index];

            //let i = 0;

            //while (i < curr_section_size)
            //{
            //    let plat_temp = curr_section[i];

            //    if (Math.abs(character.get_y() - plat_temp.get_y()) < 36)
            //    {
            //        do plat_temp.Draw(character.get_world_offset());
            //    }

            //    let i = i + 1;
            //}


            //let i = 0;

            //while (i < sections_num)
            //{
            //    let section = sections[i];

            //    if ((section.get_left_border() = 0))
            //    {
            //        do section.Draw();
            //    }
                
            //    let i = i + 1;
            //}


            let section = sections[get_curr_section_index()];

            //do Output.printInt(get_curr_section_index());
            //do Output.println();

            do section.Draw();
        }

        return;
    }



    method void move()
    {
        var int x;

        let x = character.get_x();

        do character.check_gravity(sections, get_curr_section_index(), world_offset);

        if (direction = 1) 
        {
            // move left -> scroll right

            do ScrollRight();
        }
        if (direction = 2) 
        {
            // move right -> scroll left

            do ScrollLeft();
        }

        return;
    }

    method void ScrollLeft()
    {
        var int i;
        var Section section;

        while (i < sections_num)
        {
            let section = sections[i];
            do section.ScrollLeft();

            let i = i + 1;
        }

        return;
    }

    method void ScrollRight()
    {
        var int i;
        var Section section;

        while (i < sections_num)
        {
            let section = sections[i];
            do section.ScrollRight();

            let i = i + 1;
        }

        return;
    }


    method void move2()
    {
        var int x;

        let x = character.get_x();

        do character.check_gravity(sections, get_curr_section_index(), world_offset);

        if (direction = 1) 
        {
            if (x + world_offset - screen_middle > 0)
            {
                if (x > left_border)
                {
                    do character.MoveLeft();
                }
                else
                {
                    let world_offset = world_offset - 1;
                    do scroll_sections_right();
                }
            }
            else
            {
                do character.MoveLeft();
            }
        }
        if (direction = 2) 
        {
            if (x + world_offset + screen_middle < level_width)
            {
                if (x < right_border)
                {   
                    do character.MoveRight();
                }
                else
                {
                    let world_offset = world_offset + 1;
                    do scroll_sections_left();
                }
            }
            else
            {
                do character.MoveRight();
            }
        }

        do Output.printInt(world_offset);
        do Output.println();

        return;
    }

    method void scroll_sections_left()
    {
        var int i;
        var int curr_section_index;
        var Section section;
        var int size;

        //let size = (screen_width / section_width) + 1;

        let curr_section_index = get_curr_section_index();

        // hard-coded
        let size = 9;

        // lijevo od charactera
        while (i < 4) // hard-coded
        {
            let section = sections[curr_section_index - i];
            do section.ScrollLeft();

            let i = i + 1;
        }

        let i = 1;

        // desno od charactera
        while (i < 5) // hard-coded
        {
            let section = sections[curr_section_index + i];
            do section.ScrollLeft();

            let i = i + 1;
        }

        return;
    }

    method void scroll_sections_right()
    {
        var int i;
        var int curr_section_index;
        var Section section;
        var int size;

        //let size = (screen_width / section_width) + 1;

        let curr_section_index = get_curr_section_index();

        // hard-coded
        let size = 9;

        // lijevo od charactera
        while (i < 5) // hard-coded
        {
            let section = sections[curr_section_index - i];
            do section.ScrollRight();

            let i = i + 1;
        }

        let i = 1;

        // desno od charactera
        while (i < 4) // hard-coded
        {
            let section = sections[curr_section_index + i];
            do section.ScrollRight();

            let i = i + 1;
        }

        return;
    }
}