// 16384 + 8192 = 24576

class Character
{
    field int x;
    field int y;
    field int absolute_x;
    field int memAddress;
    field int lastMemAddress;
    field int width;
    field int height;
    field int heightInPixels;
    field int forceY;
    field int gravity;
    field int jump_height;
    field bool can_jump;

    

    field int health;

    field Obstacle last_obstacle;
    field bool should_draw_last_obstacle;

    field int damage_timer;
    field int damage_cooldown;

    field int last_abs_x;

    field bool movingLeft;





    field int animationFrameCount;
	field int currFrame;

    field bool playSpecificFrame;
    field int idleFrame; // = 2

    field int animationDelay;
	field int animationTimer;

    field Array Bullets;
    field int BulletsCount;
    field int currBulletIndex;
    field Bullet currBullet;

    field int bulletTimer;
    field int bulletDelay;

    field bool canShoot;

    field int Coins;

    

    constructor Character new(int x2, int y2)
    {
        var int i;

        let x = x2;
        let y = y2;
        let memAddress = Constants.getMemAddress(x, y);
        let absolute_x = x2;

        let width = 3; // 3
        let height = 2; // 32
        let heightInPixels = height * 16;

        let gravity = 6; // 6
        let can_jump = false;
        let jump_height = 35; // 35

        let health = 3;
        let damage_cooldown = 20; // 20 game ticks

        let BulletsCount = 5;
        let Bullets = Array.new(BulletsCount);
        while (i < BulletsCount)
        {
            let Bullets[i] = Bullet.new();
            let i = i + 1;
        }
        let currBullet = Bullets[currBulletIndex];

        let bulletDelay = 10;
        let bulletTimer = bulletDelay;

        let canShoot = true;

        let lastMemAddress = memAddress;

        do Draw(memAddress, true);

        return this;
    }

    method int get_x() { return x; }

    method int get_y() { return y; }

    method int getWidth() { return width; }
    method int getHeight() { return height; }

    method int get_absolute_x() { return absolute_x; }

    method Obstacle get_last_obstacle() { return last_obstacle; }

    method bool get_should_draw_last_obstacle(){ return should_draw_last_obstacle; }

    method int get_last_abs_x() { return last_abs_x; }

    method Array getBullets() { return Bullets; }

    method int getBulletsCount() { return BulletsCount; }

    method int getHealth() { return health; }
    method int getCoins() { return Coins; }

    method void addCoin() { let Coins = Coins + 1; return; }
    method void addLife() { let health = health + 1; return; }

    method void set_x(int x2)
    {
        let x = x2;
        return;
    }

    method void set_y(int y2)
    {
        let y = y2;
        return;
    }

    method void set_absolute_x(int abs_x)
    {
        let absolute_x = abs_x;
        return;
    }

    method void set_should_draw_last_obstacle(bool s)
    {
        let should_draw_last_obstacle = s;
        return;
    }

    method void increment_absolute_x(int inc)
    {
        let absolute_x = absolute_x + inc;
        return;
    }

    method void set_draw_character_left(bool b)
    {
        let movingLeft = b;
        return;
    }



    
    method void CheckTimers()
	{
        if (bulletTimer < 1)
        {
            let canShoot = true;
            let bulletTimer = bulletDelay;
        }

		return;
	}

	method void DecrementTimers()
	{
        let bulletTimer = bulletTimer - 1;

		return;
	}
    



    method void DoEnemyAction(Enemy enemy, Array map, int mapWidth, int mapHeight, int worldOffset)
    {
        do enemy.DoActions(worldOffset, x, y);

        return;
    }

    method void CheckCollisionWithEnemy(Enemy enemy)
    {
        if (enemy.CheckCollisionWithCharacter(x, y, width, heightInPixels))
        {
            do Respawn();
            do TakeDamage();
        }

        return;
    }

    method void CheckCollisionWithBullet(Bullet bullet)
    {
        if (bullet.CheckCollisionWithEntity(x, y, width, heightInPixels))
        {
            do Respawn();
            do TakeDamage();
        }

        return;
    }

    method void CheckCollisionWithCollectable(Collectable collectable)
    {
        var int result;
        let result = collectable.CheckCollisionWithCharacter(x, y, width, heightInPixels);

        if (result = 0)
        {
            do addCoin();
            do Draw(memAddress, true);
        }
        else { if (result = 1)
        {
            do addLife();
            do Draw(memAddress, true);
        }}

        return;
    }





    method void RedrawPlatforms(int worldOffset)
    {
        do Collision.RedrawPlatforms(x, y, width, heightInPixels, worldOffset);

        return;
    }

    //// PLATFORM COLLISION
    method bool CheckCollisionWithPlatformRight(int worldOffset)
    {
        return Collision.CheckAnyPlatformCollisionRight(x, y, width, height, worldOffset);
    }

    method bool CheckCollisionWithPlatformLeft(int worldOffset)
    {
        return Collision.CheckAnyPlatformCollisionLeft(x, y, width, height, worldOffset);
    }

    //// OBSTACLE COLLISION
    method void CheckCollisionWithObstacles()
    {
        var int i;
        var bool result;

        let result = Collision.IsCollidedAnyObstacle(absolute_x, y, width, height);

        if (result)
        {
            let should_draw_last_obstacle = true;
            let last_abs_x = absolute_x;

            do TakeDamage();
            do Respawn();
        }

        if (damage_timer > 0)
        {
            let damage_timer = damage_timer - 1;
        }

        return;
    }
    
    //// MOVEMENT
    method void MoveLeft()
    {
        if (x > 0)
        {
            let lastMemAddress = memAddress;

            let x = x - 1;
            let absolute_x = absolute_x - 1;
            let memAddress = memAddress - 1;

            do Clear();
            do Draw(memAddress, true); 
        }

        return;
    }

    method void MoveRight()
    {
        if((x + width) < 32)
        {
            let lastMemAddress = memAddress;

            let x = x + 1;
            let absolute_x = absolute_x + 1;
            let memAddress = memAddress + 1;

            do Clear();
            do Draw(memAddress, true); 
        }


        return;

    }

    method void Jump()
    {
        if (can_jump)
        {
            let forceY = forceY - jump_height;
        }

        return;
    }

    method void CheckGravity(int worldOffset)
    {
        var int i;
        var Platform platform;
        var Section section;
        var bool is_on_platform;

        let lastMemAddress = memAddress;

        let can_jump = Collision.IsOnAnyPlatform(x, y, width, height, forceY, worldOffset);

        if (can_jump)
        {
            let y = Collision.getPlatformY() - 16;

            let forceY = 0;
            let memAddress = Constants.getMemAddress(x, y);

            do Clear();
            do Draw(memAddress, true);
        }
        // padanje
        else
        {
            if (y > 219)
            {
                //do Respawn();

                // take damage
            }

            let forceY = forceY + gravity;      

               
        }


        let y = y + forceY;
        let memAddress = Constants.getMemAddress(x, y);

        do Clear();
        do Draw(memAddress, true);
        

        return;
    }


    method void Respawn()
    {
        let y = 100;

        if (x - 10 < 1)
        {
            let x = x + 5;
            let absolute_x = absolute_x + 5;
        }
        else
        {
            let x = x - 10;
            let absolute_x = absolute_x - 10;
        }
        
        return;
    }

    method void TakeDamage()
    {
        // dont take damage if already taken
        if (damage_timer < 1)
        {
            do Output.printString("oof");
            do Output.println();

            let health = health - 1;
            let damage_timer = damage_cooldown;
        }

        return;
    }

    method void Shoot(int worldOffset)
    {
        var int bulletX;
        var int bulletY;

        if (movingLeft)
        {
            let bulletX = x - 1;
        }
        else
        {
            let bulletX = x + width;
        }
        let bulletY = y - Constants.getBlockHeight();

        if (canShoot)
        {
            if (currBullet.IsAvailable())
            {
                do currBullet.Shoot(bulletX, bulletY, movingLeft, worldOffset);

                let currBulletIndex = currBulletIndex + 1;

                if (currBulletIndex > (BulletsCount - 1))
                {
                    let currBulletIndex = 0;
                }
                
                let currBullet = Bullets[currBulletIndex];
            }

            let canShoot = false;
        }

        return;
    }

    method void CheckBullets(int worldOffset)
    {
        var int i;
        var Bullet bullet;

        while (i < BulletsCount)
        {
            let bullet = Bullets[i];
            do bullet.CheckBullet(worldOffset);
            let i = i + 1;
        }

        return;
    }

    //// DRAW/CLEAR
    method void Clear()
	{
		do Draw(lastMemAddress, false);

		return;
	}

    method void Draw(int m, bool display)
    {
		if (~(memAddress = lastMemAddress))
		{
			do Jeff.DrawFrame(m, display, movingLeft, x, y);
		}
		
		return;
    }
}