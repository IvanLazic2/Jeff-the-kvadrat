class Collision
{

    //// PLATFORMS
    static int lastY;
    static int platformY;

    
    function void init()
    {
        return;
    }

    function int getLastY() { return lastY; }
    function int getPlatformY() { return platformY; }

    function int getNearestPlatformY(int col, int y, int height, int mapHeight)
    {
        var int currIndex;
        var int nearestPlatformY;

        let currIndex = (y/16) + 1;

        

        while (currIndex < mapHeight)
        {
            if (Constants.IsInScreenY(y + 16))
            {
                if (Collision.IsPlatform(Map.getValue(col, currIndex)))
                { 
                    let nearestPlatformY = currIndex * 16;
                    let currIndex = mapHeight;
                }
            }
            

            let currIndex = currIndex + 1;
        }

        return nearestPlatformY;
    }

    function bool IsOnAnyPlatform(int x, int y, int width, int height, int forceY, Array map, int mapWidth, int mapHeight, int worldOffset)
    {
        var bool is_stable_x;
        var bool is_stable_y;
        var int platform_x;
        var int h;
        var int w;
        var int nearestPlatformY;
        var int i;
        var int minNearestPlatformY;
        var int py;

        let minNearestPlatformY = (mapHeight - 1) * 16;
        while (i < width)
        {
            let py = Collision.getNearestPlatformY(x + i + worldOffset, y, height, mapHeight);
            if (~(py = 0) & (py < minNearestPlatformY))
            {
                let minNearestPlatformY = py;
            }

            let i = i + 1;
        }

        let platformY = minNearestPlatformY;

        let h = minNearestPlatformY - y - Constants.getBlockHeight();
        let is_stable_y = (-1 < h) & (h < (forceY + 1));

        if (Math.abs(y + Constants.getBlockHeight() + forceY - minNearestPlatformY) < 7) // < 15
        {
            let is_stable_y = true;
        }

        return is_stable_y;
    }

    function bool CheckAnyPlatformCollisionRight(int x, int y, int width, int height, Array map, int mapWidth, int mapHeight, int worldOffset, int forceY)
    {
        var int i;
        var bool result;

        let i = ((y + 8)/16);
        while (i > ((y/16) - height))
        {
            let result = result | (Collision.IsPlatform(Map.getValue(x + width + worldOffset, i)));

            let i = i - 1;
        }

        return result;
    }

    function bool CheckAnyPlatformCollisionLeft(int x, int y, int width, int height, Array map, int mapWidth, int mapHeight, int worldOffset, int forceY)
    {
        var int i;
        var bool result;

        let i = ((y + 8)/16);
        while (i > ((y/16) - height))
        {
            let result = result | (Collision.IsPlatform(Map.getValue(x - 1 + worldOffset, i)));
            let i = i - 1;
        }

        return result;
    }

    function bool IsPlatform(int value)
    {
        return ((0 < value) & (value < 11));
    }   

    function bool IsObstacle(int value)
    {
        return ((10 < value) & (value < 16));
    }

    function bool IsCollectable(int value)
    {
        return ((15 < value) & (value < 18));
    }

    function bool GetPlatformType(int value)
    {
        return value - 1;
    }   

    //function bool GetObstacleType(int value)
    //{
    //    return value - 10 - 1;
    //}
//
    //function bool GetCollectableType(int value)
    //{
    //    return ;
    //}


    function bool IsAtPlatformBoundaryLeft(int x, int y, int width, int height, Array map, int mapWidth, int mapHeight, int worldOffset)
    {
        var bool result;

        let result = ~Collision.IsPlatform(Map.getValue(x - 1 + worldOffset, (y/16) + 1));

        return result;
    }

    function bool IsAtPlatformBoundaryRight(int x, int y, int width, int height, Array map, int mapWidth, int mapHeight, int worldOffset)
    {
        var Array x_map;
        var bool result;

        let result = ~Collision.IsPlatform(Map.getValue(x + width + worldOffset, (y/16) + 1));

        return result;
    }





    //// OBSTACLES

    function bool IsCollidedAnyObstacle(int x, int y, int width, int height, Array map, int mapWidth, int mapHeight)
    {
        //var Array x_map;
        var bool result;
        var int i;
        var int j;
        var int blockValue;

        while (i < width)
        {
            //let x_map = map[x + i];

            let j = (y/16) - (height - 1); // TEMP -> Jeff height is 16

            while (j < ((y/16) + 1)) // y + blockHeight
            {
                let result = result | (Collision.IsObstacle(Map.getValue(x + i, j)));

                let j = j + 1;
            }

            if (result)
            {
                let i = width;
            }

            let i = i + 1;
        }
        
        return result;
    }

    function bool IsCollidedObstacle(Obstacle obstacle, int x, int y, int width, int height)
    {
        var bool is_collided_y;
        var bool is_collided_x;

        let is_collided_x = (((x + width) > (obstacle.get_x()) & (x < (obstacle.get_x() + obstacle.get_size()))));
        let is_collided_y = (obstacle.get_y() - obstacle.get_height() < (y + height)) & (y < (obstacle.get_y() + 1));
        
        return is_collided_x & is_collided_y;
    }

    function void RedrawPlatforms(Array map, int mapWidth, int mapHeight, int x, int y, int width, int height, int worldOffset)
    {
        var int i;
        var int j;
        var int px;
        var int py;
        var int location;
        var int memAddress;

        if (Constants.IsInScreenX(x - 1) & Constants.IsInScreenX(x + width + 1))
        {
            let i = x - 1;
            while (i < (x + width + 1))
            {
                let j = ((y - height) / 16) - 2;
                while (j < (((y + Constants.getBlockHeight()) / 16) + 2))
                {
                    if (((i + worldOffset) < mapWidth) & (j < mapHeight))
                    {
                        if (Collision.IsPlatform(Map.getValue(i + worldOffset, j)))
                        {
                            let location = (j * 512) + i; // 16 * 32 = 512
		                    let memAddress = 16384 + location;

                            do Platform.DrawBlock(0, Map.getValue(i + worldOffset, j) - 1, memAddress);
                        }
                    }
                    

                    let j = j + 1;
                }

                let i = i + 1;
            }
        }
        

        return;
    }

    function bool IsEntityCollidedWithEntitySides(int cx, int cy, int cw, int ch, int ex, int ey, int ew, int eh)
    {
        var bool is_collided;

        let is_collided = (ex < (cx + cw)) & (cx < (ex + ew)) & ((ey - 16) < cy) & (cy < (ey + eh));

        return is_collided;
    }

    function bool IsEntityCollidedWithEntityTop(int cx, int cy, int cw, int ch, int ex, int ey, int ew, int eh)
    {
        var bool is_collided;

        let is_collided = (ex < (cx + cw)) & (cx < (ex + ew)) & ((ey - eh - 24) < (cy)) & ((cy) < (ey - eh));

        return is_collided;
    }

    function bool IsBulletCollidedWithMap(Array map, int mapWidth, int mapHeight, int x, int y, bool drawLeft, int worldOffset)
    {
        var bool result;
        var int col;

        if (Constants.IsInScreen(x, y))
        {
            if (drawLeft)
            {
                let col = x - 2 + worldOffset;
            }
            else 
            {
                let col = x + 2 + worldOffset;
            }

            let result = (Map.getValue(col, (y + 8)/16) = 0);
        }

        return ~result;
    }

    function bool IsBulletCollidedWithEntity(int ex, int ey, int ew, int eh, int bx, int by)
    {
        var bool colx;
        var bool coly;

        
        let colx = (bx < (ex + ew)) & ((bx + 1) > ex);

        //do Output.printInt(colx);



        let coly = (by > (ey - eh + 15)) & (by < (ey + 16));

        //return Collision.IsEntityCollidedWithEntitySides(bx, by, 1, 16, ex, ey, ew, eh);
        return colx & coly ;
    }



    function bool HasPlatformAbove(int x, int y, int width, int worldOffset, bool movingLeft)
    {
        var int i;
        var int j;
        var int limit;
        var bool result;

        if (movingLeft)
        {
            let i = x - 3; // 1
            let limit = x;
        }
        else
        {
            let i = x + width - 1;
            let limit = x + width + 2; //x + width
        }

        while (i < limit)
        {
            let j = 0;
            while (j < 4)
            {
                if ((y/16) - j > -1)
                {
                    let result = result | (Collision.IsPlatform(Map.getValue(i + worldOffset, (y/16) - j)));
                }
                
                let j = j + 1;
            }

            let i = i + 1;
        }
        
        return result;
    }

    function bool HasObstacleBelow(int x, int y, int width, int worldOffset, bool movingLeft)
    {
        var int i;
        var int j;
        var int limit;
        var bool result;

        if (movingLeft)
        {
            let i = x;
            let limit = x + 1;
        }
        else
        {
            let i = x + width - 1;
            let limit = x + width;
        }

        while (i < limit)
        {
            let j = y/16;
            while (j < 16)
            {
                let result = result | (Collision.IsObstacle(Map.getValue(i + worldOffset, j)));
                let j = j + 1;
            }

            let i = i + 1;
        }

        return result;
    }

    function int GetObstacleBelowY(int x, int y, int width, int worldOffset, bool movingLeft)
    {
        var int i;
        var int j;
        var int limit;
        var int result;

        if (movingLeft)
        {
            let i = x;
            let limit = x + 1;
        }
        else
        {
            let i = x + width - 1;
            let limit = x + width;
        }

        let result = 16;
        while (i < limit)
        {
            let j = y/16;
            while (j < 16)
            {
                if (Collision.IsObstacle(Map.getValue(i + worldOffset, j)))
                {
                    if (j < result)
                    {
                        let result = j;
                    }
                }
                let j = j + 1;
            }
            let i = i + 1;
        }

        //do Output.printInt(result);
        //do Output.printChar(32);

        return result;
    }

    function bool GetPlatformBelowY(int x, int y, int width, int worldOffset, bool movingLeft)
    {
        var int i;
        var int j;
        var int limit;
        var int result;

        if (movingLeft)
        {
            let i = x - 2;
            let limit = x + 1;
        }
        else
        {
            let i = x + width - 1;
            let limit = x + width + 2; // + 2 s movement delayom 3
        }

        let result = 16;
        while (i < limit)
        {
            let j = y/16;
            while (j < 16)
            {
                if (Collision.IsPlatform(Map.getValue(i + worldOffset, j)))
                {
                    if (j < result)
                    {
                        let result = j;
                    }
                }
                let j = j + 1;
            }

            let i = i + 1;
        }

        

        return result;
    }

    
}