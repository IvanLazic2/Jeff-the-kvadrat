// 0 - spider
// 1 - evil jeff melee
// 2 - evil jeff ranged
// 3 - bat


class Enemy
{
	field int x;
	field int y;
	field int type;

	field int width; // spider - 1
	field int height; // spider - 16

	field int location;
	field int lastLocation;
	field int memAddress;
	field int lastMemAddress;

	field int gravity;
	field bool canJump;
	field int forceY;
	field int jumpHeight;



	//field int animationFrameCount;
	//field int currFrame;

	//field int animationDelay;
	//field int animationTimer;

	field int movementDelay;
	field int movementTimer;





	field bool canMove;

	field bool movingLeft;




	field bool IsRoaming;
    field bool IsFlying;
    field bool IsGravityAffected;
    field bool IsMelee;
    field bool IsShooting;
    field bool IsDamageOnSquish;
	field bool IsFollowing;
	field bool IsStacionary;

	field bool IsAlive;


	field int HeightInPixels;


	field Array Bullets;
    field int BulletsCount;
    field int currBulletIndex;
    field Bullet currBullet;

    field int bulletTimer;
    field int bulletDelay;

    field bool canShoot;




    constructor Enemy new(int x2, int y2, int type2)
    {	
		var int i;

		let x = x2;
		let y = y2;
		let type = type2;

		let location = (32 * y) + x;
		let memAddress = 16384 + location;

		// SPIDER
		if (type = 0)
		{
			let width = 2;
			let height = 1;
			//let animationFrameCount = Spider.GetFrameCount();
			//let animationDelay = 3;
			let movementDelay = 2;

			let IsRoaming = true;
		}
		// EVIL JEFF MELEE
		else { if (type = 1)
		{
			let width = 3;
			let height = 2;
			//let animationFrameCount = EvilJeffMelee.GetAnimationFrameCount();
			
			//let animationDelay = 3;
			let movementDelay = 2;



			//let IsGravityAffected = true;
			//let IsMelee = true;
			//let IsDamageOnSquish = true;
			//let IsFollowing = true;
			let IsStacionary = true;
			//let IsShooting = true;
			//let IsRoaming = true; // TEMP
		}
		else { if (type = 2)
		{
			let width = 3;
			let height = 2;

			let movementDelay = 2;



			let IsGravityAffected = true;
			let IsMelee = true;
		}
		else { if (type = 3)
		{
			let width = 2;
			let height = 1;

			let IsStacionary = true;
		}}}}

		if (IsShooting)
		{
			let BulletsCount = 1;
        	let Bullets = Array.new(BulletsCount);
        	while (i < BulletsCount)
        	{
        	    let Bullets[i] = Bullet.new();
        	    let i = i + 1;
        	}
        	let currBullet = Bullets[currBulletIndex];
		}

		//let currFrame = 0;

		//let animationTimer = animationDelay;

		let HeightInPixels = height * 16;

		let movementTimer = movementDelay;

		let canMove = true;

		let forceY = 0;
		let gravity = 6; // 6
		let jumpHeight = 30; // 30

		let IsAlive = true;

		let bulletDelay = 10;
        let bulletTimer = bulletDelay;

		let lastLocation = location;


        return this;
    }

	method int get_x() { return x; }
	method int get_y() { return y; }
	method int getWidth() { return width; }
	method int getHeight() { return HeightInPixels; }
	method int get_type() { return type; }

	method bool getIsRoaming() { return IsRoaming; }
    method bool getIsFlying() { return IsFlying; }
    method bool getIsGravityAffected() { return IsGravityAffected; }
    method bool getIsMelee() { return IsMelee; }
    method bool getIsShooting() { return IsShooting; }
    method bool getIsDamageOnSquish() { return IsDamageOnSquish; }
	method bool getIsFollowing() { return IsFollowing; }
	method bool getIsStacionary() { return IsStacionary; }

	method bool getIsAlive() { return IsAlive; }
	method Array getBullets() { return Bullets; }
	method int getBulletsCount() { return BulletsCount; }

	method void set_x(int x2)
    {
        let x = x2;
        return;
    }

    method void set_y(int y2)
    {
        let y = y2;
        return;
    }

	method void CheckTimers()
	{
		if (movementTimer < 1)
		{
			let canMove = true;
			let movementTimer = movementDelay;
		}

		if (bulletTimer < 1)
        {
            let canShoot = true;
            let bulletTimer = bulletDelay;
        }
		

		// CHECK TIMERS ZA SVE VRSTRE ENEMYJA - ZASAD NE


		return;
	}

	method void DecrementTimers()
	{
		let movementTimer = movementTimer - 1;
		let bulletTimer = bulletTimer - 1;


		return;
	}





	method void DoActions(Array map, int mapWidth, int mapHeight, int worldOffset)
	{
		if (IsAlive)
		{
			if (IsGravityAffected)
			{
				do check_gravity2(map, mapWidth, mapHeight, worldOffset);
				do Collision.RedrawPlatforms(map, mapWidth, mapHeight, x, y, width, height, worldOffset);

				
			}
			if (IsRoaming)
			{
				do Roam(map, mapWidth, mapHeight, worldOffset);
			}
			if (IsMelee)
			{
				do Jump();
			}
			if (IsShooting)
			{
				do Shoot();
			}
			if (IsStacionary)
			{
				//do Clear();
				do Draw(memAddress, true, false);
			}

		}

		return;
	}








	method void Shoot()
    {
        var int bulletX;
        var int bulletY;

        if (movingLeft)
        {
            let bulletX = x - 1;
        }
        else
        {
            let bulletX = x + width;
        }
        let bulletY = y - Constants.getBlockHeight();

        if (canShoot)
        {
            if (currBullet.IsAvailable())
            {
                do currBullet.Shoot(bulletX, bulletY, movingLeft);

                let currBulletIndex = currBulletIndex + 1;

                if (currBulletIndex > (BulletsCount - 1))
                {
                    let currBulletIndex = 0;
                }
                
                let currBullet = Bullets[currBulletIndex];
            }

            let canShoot = false;
        }

        return;
    }

    method void CheckBullets(Array map, int mapWidth, int mapHeight)
    {
        var int i;
        var Bullet bullet;

		if (IsShooting)
		{
			while (i < BulletsCount)
        	{
        	    let bullet = Bullets[i];
        	    do bullet.CheckBullet(map, mapWidth, mapHeight);
        	    let i = i + 1;
        	}
		}

        return;
    }











	//// MOVEMENT
	method void Roam(Array map, int mapWidth, int mapHeight, int worldOffset)
	{
		

		if (movingLeft)
		{
			do MoveLeft();
		}
		else 
		{
			do MoveRight();
		}

		if (Collision.CheckAnyPlatformCollisionLeft(x, y, width, height, map, mapWidth, mapHeight, worldOffset, forceY) | 
		    Collision.IsAtPlatformBoundaryLeft(x, y, width, height, map, mapWidth, mapHeight, worldOffset))
		{
			let movingLeft = false;
		}
		else { if (Collision.CheckAnyPlatformCollisionRight(x, y, width, height, map, mapWidth, mapHeight, worldOffset, forceY) | 
		           Collision.IsAtPlatformBoundaryRight(x, y, width, height, map, mapWidth, mapHeight, worldOffset))
		{
			let movingLeft = true;
		}}

		return;
	}



	method void ScrollRight()
	{
		if (IsAlive)
		{
			let lastLocation = location;

			do Clear();

			let location = location + 1;
			let memAddress = 16384 + location;
        	let x = x + 1;

			do Draw(memAddress, true, movingLeft);

			
		}

        return;
	}

	method void ScrollLeft()
    {
		if (IsAlive)
		{
			let lastLocation = location;

			do Clear();

			let location = location - 1;
			let memAddress = 16384 + location;
			let x = x - 1;

			do Draw(memAddress, true, movingLeft);

			
		}	

		return;
    }

    method void MoveLeft()
    {
		let movingLeft = true;
		if (canMove)
		{
			let lastLocation = location;

			do Clear();

			let location = location - 1;
			let memAddress = 16384 + location;
       		let x = x - 1;

			do Draw(memAddress, true, true);

			let canMove = false;
		}
       	return;
		
    }

    method void MoveRight()
    {
		let movingLeft = false;

		if (canMove)
		{
			let lastLocation = location;

			do Clear();

			let location = location + 1;
			let memAddress = 16384 + location;
			let x = x + 1;

			do Draw(memAddress, true, false);

			let canMove = false;

		}
        	return;
    }

    method void Jump()
    {
        let lastLocation = location;

        if (canJump)
        {
            let forceY = forceY - jumpHeight;
        }

        return;
    }

	//// GRAVITY

	method void check_gravity2(Array map, int mapWidth, int mapHeight, int worldOffset)
    {
        var int i;
        var Platform platform;
        var Section section;
        var bool is_on_platform;

        let lastLocation = location;

        let canJump = Collision.IsOnAnyPlatform(x, y, width, height, forceY, map, mapWidth, mapHeight, worldOffset);


        if (canJump)
        {
			
			do Clear();

			

            let y = Collision.getPlatformY() - 16; // blockHeight = 16
            let forceY = 0;
            let location = (y * 32) + x;
			let memAddress = 16384 + location;

            //do Clear();
            //do Draw();
			
			do Draw(memAddress, true, false);
        }
        // padanje
        else
        {
            if (y > 219)
            {
                // do Die();
            }

            let forceY = forceY + gravity;            
        }

		
		do Clear();

        let y = y + forceY;
        let location = (y * 32) + x;
		let memAddress = 16384 + location;
		
		do Draw(memAddress, true, false);

        return;
    }

    method void check_gravity(Array platforms, int platforms_num)
    {
        var int i;
        var Platform platform;
        var Section section;
        var bool isOnPlatform;

        let lastLocation = location;

        while (i < platforms_num)
        {
            let platform = platforms[i];

            //if (Math.abs(y - platform.get_y()) < 50)
            //{
                let isOnPlatform = Collision.IsOnPlatform(platform, x, y, width, height, forceY);

                let canJump = isOnPlatform;

                if (isOnPlatform)
                {
                    let i = platforms_num - 1;
                }
            //}

            let i = i + 1;
        }

        if (canJump)
        {
			

            let y = platform.get_y() - height;
            let forceY = 0;
            let location = (y * 32) + x;
			//let memAddress = 16384 + location;

            //do Clear();
            //do Draw();
			do Clear();
			do Draw(16384 + location, true, false);
        }
        // padanje
        else
        {
            if (y > 219)
            {
                //do Respawn();

                // take damage
            }

            let forceY = forceY + gravity;            
        }

		

        let y = y + forceY;
        let location = (y * 32) + x;
        
        //do Clear();
        //do Draw();
		do Clear();
		do Draw(16384 + location, true, false);

        return;
    }


	method void Die()
	{
		var int i;
		var Bullet bullet;

		do Output.printString("dead");
		do Output.println();

		do Clear();
		let IsAlive = false;

		let x = -10;
		let y = -10;

		let location = (32 * y) + x;
		let memAddress = 16384 + location;
		

		return;
	}

	//method bool IsInScreen()
	//{
	//	return ((-1 < x) & ((x + width) < 32));
	//}

	method void Clear()
	{
		//if (~(lastLocation = location))
		//{
		//	do Draw(16384 + lastLocation, false, movingLeft);
		//}

		do Draw(16384 + location, false, movingLeft);

		return;
	}

	//ethod void Draw(int memAddress, bool display, bool mirrored)
	//
	//	if (display)
	//	{
	//		if (IsInScreen())
	//		{
	//			do DrawEnemyTypes(memAddress, display, mirrored);
	//		}
	//	}
	//	else
	//	{
	//		if ((0 < (x + width)) & ((x + width) < 32))
	//		{
	//			do DrawEnemyTypes(memAddress, display, mirrored);
	//		}
	//	}

	//	return;
	//

    method void Draw(int memAddress, bool display, bool mirrored)
    {
		if (IsAlive)
		{
			if (type = 0)
			{
				do Spider.DrawFrame(memAddress, display, mirrored, x, y);
			}
			// EVIL JEFF MELEE
			else { if (type = 1)
			{
				do EvilJeffMelee.DrawFrame(memAddress, display, mirrored, x, y);
			}
			else { if (type = 2)
			{
				do EvilJeffRanged.DrawFrame(memAddress, display, mirrored, x, y);
			}
			else { if (type = 3)
			{
				do Bat.DrawFrame(memAddress, display, mirrored, x, y);
			}}}}
		}
		

		return;
    }

}

