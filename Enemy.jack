// 0 - spider
// 1 - evil jeff melee
// 2 - evil jeff ranged
// 3 - bat


class Enemy
{
	field int x;
	field int y;
	field int type;

	field int width; 
	field int height;
	field int heightInPixels;

	field int location;
	field int lastLocation;
	field int memAddress;
	field int lastMemAddress;

	field int gravity;
	field bool canJump;
	field int forceY;
	field int jumpHeight;



	//field int animationFrameCount;
	//field int currFrame;

	//field int animationDelay;
	//field int animationTimer;

	field int movementDelay;
	field int movementTimer;





	field bool canMoveLeftRight;
	field bool canMoveUpDown;

	field bool movingLeft;




	field bool IsRoaming;
    field bool IsFlying;
    field bool IsGravityAffected;
    field bool IsMelee;
	field bool IsRanged;
    field bool IsShooting;
    field bool DiesOnSquish;
	field bool IsFollowing;
	field bool IsStacionary;

	field bool IsAlive;


	field Array Bullets;
    field int BulletsCount;
    field int currBulletIndex;
    field Bullet currBullet;

    field int bulletTimer;
    field int bulletDelay;

    field bool canShoot;

	field bool hasPlatformAbove;
	field int hasPlatformAboveTimer;
	field int hasPlatformAboveDelay;




    constructor Enemy new(int x2, int y2, int type2)
    {	
		var int i;

		let x = x2;
		let y = y2;
		let type = type2;

		let location = (32 * y) + x;
		let memAddress = 16384 + location;

		// SPIDER
		if (type = 0)
		{
			let width = 2;
			let height = 1;
			let movementDelay = 2;

			let IsRoaming = true;
			//let IsStacionary = true;
		}
		// EVIL JEFF MELEE
		else { if (type = 1)
		{
			let width = 3;
			let height = 2;
			
			let movementDelay = 2;



			let IsGravityAffected = true;
			let IsMelee = true;



			//let IsFollowing = true;
			//let IsStacionary = true;
			//let IsShooting = true;
			//let IsRoaming = true; // TEMP
		}
		// EVIL JEFF RANGED
		else { if (type = 2)
		{
			let width = 3;
			let height = 2;

			let movementDelay = 3;

			let IsGravityAffected = true;
			let IsShooting = true;
			let IsRanged = true;

			//let IsStacionary = true;
			let DiesOnSquish = true;
		}
		// BAT
		else { if (type = 3)
		{
			let width = 2;
			let height = 1;

			let movementDelay = 5;

			let IsStacionary = true;
			//let IsFollowing = true;
			//let IsFlying = true;
			let DiesOnSquish = true;
		}}}}

		if (IsShooting)
		{
			let BulletsCount = 1;
        	let Bullets = Array.new(BulletsCount);
        	while (i < BulletsCount)
        	{
        	    let Bullets[i] = Bullet.new();
        	    let i = i + 1;
        	}
        	let currBullet = Bullets[currBulletIndex];
		}

		let heightInPixels = height * 16;

		let movementTimer = movementDelay;

		let canMoveLeftRight = true;
		let canMoveUpDown = true;

		let forceY = 0;
		let gravity = 6; // 6
		let jumpHeight = 30; // 30

		let IsAlive = true;

		let bulletDelay = 10;
        let bulletTimer = bulletDelay;

		let hasPlatformAboveDelay = 5;
		let hasPlatformAboveTimer = hasPlatformAboveDelay;

		do Draw(memAddress, true, false);

		let lastLocation = location;


        return this;
    }

	method int get_x() { return x; }
	method int get_y() { return y; }
	method int getWidth() { return width; }
	method int getHeight() { return height; }
	method int get_type() { return type; }

	method bool getIsRoaming() { return IsRoaming; }
    method bool getIsFlying() { return IsFlying; }
    method bool getIsGravityAffected() { return IsGravityAffected; }
    method bool getIsMelee() { return IsMelee; }
    method bool getIsShooting() { return IsShooting; }
    //method bool getDiesOnSquish() { return DiesOnSquish; }
	method bool getIsFollowing() { return IsFollowing; }
	method bool getIsStacionary() { return IsStacionary; }

	method bool getIsAlive() { return IsAlive; }
	method Array getBullets() { return Bullets; }
	method int getBulletsCount() { return BulletsCount; }

	method void set_x(int x2)
    {
        let x = x2;
        return;
    }

    method void set_y(int y2)
    {
        let y = y2;
        return;
    }

	method void CheckTimers()
	{
		if (movementTimer < 1)
		{
			let canMoveLeftRight = true;
			let canMoveUpDown = true;
			let movementTimer = movementDelay;
		}

		if (bulletTimer < 1)
        {
            let canShoot = true;
            let bulletTimer = bulletDelay;
        }
		

		// CHECK TIMERS ZA SVE VRSTRE ENEMYJA - ZASAD NE (za animacije)


		return;
	}

	method void DecrementTimers()
	{
		let movementTimer = movementTimer - 1;
		let bulletTimer = bulletTimer - 1;


		return;
	}




	
	method bool CheckCollisionWithCharacter(int cx, int cy, int cw, int ch)
	{
		if (IsAlive)
		{
			if (DiesOnSquish & Collision.IsEntityCollidedWithEntityTop(cx, cy, cw, ch, x, y, width, heightInPixels))
			{
				do Die();
				return false;
			}
			else { if (Collision.IsEntityCollidedWithEntitySides(cx, cy, cw, ch, x, y, width, heightInPixels))
			{
				return true;
			}}
		}
		
		return false;
	}

	method void CheckCollisionWithBullet(Bullet bullet)
    {
		if (IsAlive)
		{
			if (bullet.CheckCollisionWithEntity(x, y, width, heightInPixels))
			{
				do Die();
			}
		}

		return;
    }



	method void DoActions(int worldOffset, int cx, int cy)
	{
		if (IsAlive)
		{
			if (IsGravityAffected)
			{
				do CheckGravity(worldOffset);
				do Collision.RedrawPlatforms(x, y, width, heightInPixels, worldOffset);
			}
			if (IsRoaming)
			{
				do Roam(worldOffset);
			}
			if (IsMelee)
			{
				do Melee(worldOffset, cx, cy);
			}
			if (IsRanged)
			{
				do Ranged(worldOffset, cx, cy);
			}
			//if (IsShooting)
			//{
			//	do Shoot(worldOffset);
			//}
			if (IsStacionary)
			{
				//do Clear();
				do Draw(memAddress, true, false);
			}
			if (IsFollowing & IsFlying)
			{
				do FollowFlying(worldOffset, cx, cy);
			}

		}

		return;
	}








	method void Shoot(int worldOffset)
    {
        var int bulletX;
        var int bulletY;

        if (movingLeft)
        {
            let bulletX = x - 1;
        }
        else
        {
            let bulletX = x + width;
        }
        let bulletY = y - Constants.getBlockHeight();

        if (canShoot)
        {
            if (currBullet.IsAvailable())
            {
                do currBullet.Shoot(bulletX, bulletY, movingLeft, worldOffset);

                let currBulletIndex = currBulletIndex + 1;

                if (currBulletIndex > (BulletsCount - 1))
                {
                    let currBulletIndex = 0;
                }
                
                let currBullet = Bullets[currBulletIndex];
            }

            let canShoot = false;
        }

        return;
    }

    method void CheckBullets(int worldOffset)
    {
        var int i;
        var Bullet bullet;

		if (IsShooting)
		{
			while (i < BulletsCount)
        	{
        	    let bullet = Bullets[i];
        	    do bullet.CheckBullet(worldOffset);
        	    let i = i + 1;
        	}
		}

        return;
    }











	//// MOVEMENT
	method void FollowGravity(int worldOffset, int cx, int cy)
	{
		if (hasPlatformAboveTimer < 0)
		{
			let hasPlatformAbove = Collision.HasPlatformAbove(x, y, width, worldOffset, movingLeft);
			let hasPlatformAboveTimer = hasPlatformAboveDelay;
		}
		else
		{
			let hasPlatformAboveTimer = hasPlatformAboveTimer - 1;
		}

		if (hasPlatformAbove)
		{
			if (((x - cx) > 0))
			{
				do MoveLeft(worldOffset);
			}
			if (((x - cx) < 0))
			{
				do MoveRight(worldOffset);
			}
			do Jump();	
		}
		else
		{
			if (Collision.GetPlatformBelowY(x, y, width, worldOffset, true) < Collision.GetObstacleBelowY(x, y, width, worldOffset, true))
			{
				if (((x - cx) > 0))
				{
					do MoveLeft(worldOffset);
				}
			}
			if (Collision.GetPlatformBelowY(x, y, width, worldOffset, false) < Collision.GetObstacleBelowY(x, y, width, worldOffset, false))
			{
				if (((x - cx) < 0))
				{
					do MoveRight(worldOffset);
				}
			}
		}

		return;
	}

	method void Melee(int worldOffset, int cx, int cy)
	{
		if (Constants.IsInScreenX(x))
		{
			do FollowGravity(worldOffset, cx, cy);
		}

		return;
	}

	method void Ranged(int worldOffset, int cx, int cy)
	{
		if (Constants.IsInScreenX(x))
		{
			if (Math.abs(x - cx) > 10)
			{
				do FollowGravity(worldOffset, cx, cy);
			}
			else
			{
				if (IsShooting)
				{
					if ((x - cx) < 0)
					{
						let movingLeft = false;
					}
					else
					{
						let movingLeft = true;
					}

					do Shoot(worldOffset);
				}
			}
		}

		return;
	}


	method void FollowFlying(int worldOffset, int cx, int cy)
	{

		if (((x - cx) > 0) & (Map.getValue(x - 1 + worldOffset, y/16) = 0))
		{
			do MoveLeft(worldOffset);
		}
		if (((x - cx) < 0) & (Map.getValue(x + width + worldOffset, y/16) = 0))
		{
			do MoveRight(worldOffset);
		}
		if (((y - cy) > 0) & (Map.getValue(x + worldOffset, (y/16) - height) = 0))
		{
			do MoveUp();
		}
		if (((y - cy) < 0) & (Map.getValue(x + worldOffset, (y/16) + 1) = 0))
		{
			do MoveDown();
		}

		return;

	}



	method void Roam(int worldOffset)
	{
		

		if (movingLeft)
		{
			do MoveLeft(worldOffset);
		}
		else 
		{
			do MoveRight(worldOffset);
		}

		if (Collision.CheckAnyPlatformCollisionLeft(x, y, width, height, worldOffset) | 
		    Collision.IsAtPlatformBoundaryLeft(x, y, width, height, worldOffset))
		{
			let movingLeft = false;
		}
		else { if (Collision.CheckAnyPlatformCollisionRight(x, y, width, height, worldOffset) | 
		           Collision.IsAtPlatformBoundaryRight(x, y, width, height, worldOffset))
		{
			let movingLeft = true;
		}}

		return;
	}



	method void ScrollRight()
	{
		if (IsAlive)
		{
			//let lastLocation = location;

			

			let lastLocation = location;
			let location = location + 1;
			let memAddress = 16384 + location;
        	let x = x + 1;

			do Clear();
			do Draw(memAddress, true, movingLeft);

			
		}

        return;
	}

	method void ScrollLeft()
    {
		if (IsAlive)
		{
			//let lastLocation = location;

			let lastLocation = location;
			let location = location - 1;
			let memAddress = 16384 + location;
			let x = x - 1;

			do Clear();
			do Draw(memAddress, true, movingLeft);

			
		}	

		return;
    }

    method void MoveLeft(int worldOffset)
    {
		let movingLeft = true;

		if (canMoveLeftRight & (Map.getValue(x - 1 + worldOffset, y/16) = 0))
		{
			let lastLocation = location;
			let location = location - 1;
			let memAddress = 16384 + location;
       		let x = x - 1;

			do Clear();
			do Draw(memAddress, true, true);

			let canMoveLeftRight = false;
		}
       	return;
		
    }

    method void MoveRight(int worldOffset)
    {
		let movingLeft = false;

		if (canMoveLeftRight & (Map.getValue(x + width + worldOffset, y/16) = 0))
		{

			let lastLocation = location;
			let location = location + 1;
			let memAddress = 16384 + location;
			let x = x + 1;

			do Clear();
			do Draw(memAddress, true, false);

			let canMoveLeftRight = false;

		}
        	return;
    }

	method void MoveUp()
    {
		let movingLeft = false;

		if (canMoveUpDown)
		{
			let lastLocation = location;
			let location = location - 512;
			let memAddress = 16384 + location;
			let y = y - 16;

			do Clear();
			do Draw(memAddress, true, false);

			let canMoveUpDown = false;

		}
        	return;
    }

	method void MoveDown()
    {
		let movingLeft = false;

		if (canMoveUpDown)
		{
			let lastLocation = location;
			let location = location + 512;
			let memAddress = 16384 + location;
			let y = y + 16;

			do Clear();
			do Draw(memAddress, true, false);

			let canMoveUpDown = false;

		}
        	return;
    }

    method void Jump()
    {
        //let lastLocation = location;

        if (canJump)
        {
            let forceY = forceY - jumpHeight;
        }

        return;
    }

	//// GRAVITY

	method void CheckGravity(int worldOffset)
    {
        var int i;
        var Platform platform;
        var Section section;
        var bool is_on_platform;

        

        let canJump = Collision.IsOnAnyPlatform(x, y, width, height, forceY, worldOffset);


        if (canJump)
        {
            let y = Collision.getPlatformY() - 16;

            let forceY = 0;
			let lastLocation = location;
            let location = (y * 32) + x;
			let memAddress = 16384 + location;
			
			do Clear();
			do Draw(memAddress, true, movingLeft);
        }
        // padanje
        else
        {
            if (y > 219)
            {
                // do Die();
            }

            let forceY = forceY + gravity;            
        }

        let y = y + forceY;

		let lastLocation = location;
        let location = (y * 32) + x;
		let memAddress = 16384 + location;
		
		do Clear();
		do Draw(memAddress, true, movingLeft);

        return;
    }

	method void Die()
	{
		var int i;
		var Bullet bullet;

		do Output.printString("dead");
		do Output.println();

		do Draw2(16384 + lastLocation, false, movingLeft);
		let IsAlive = false;

		let x = -10;
		let y = -10;

		let location = (32 * y) + x;
		let memAddress = 16384 + location;
		

		return;
	}

	method void Clear()
	{
		//if (~(lastLocation = location))
		//{
		//	do Draw(16384 + lastLocation, false, movingLeft);
		//}

		do Draw(16384 + lastLocation, false, movingLeft);

		return;
	}

    method void Draw(int memAddress, bool display, bool mirrored)
    {
		if (IsAlive)
		{
			if (~(location = lastLocation))
			{
				do DrawTypes(memAddress, display, mirrored);
			}	
		}
		
		return;
    }
	method void Draw2(int memAddress, bool display, bool mirrored)
    {
		if (IsAlive)
		{
			do DrawTypes(memAddress, display, mirrored);
		}
		
		return;
    }

	method void DrawTypes(int memAddress, bool display, bool mirrored)
    {
		if (type = 0)
		{
			do Spider.DrawFrame(memAddress, display, mirrored, x, y);
		}
		else { if (type = 1)
		{
			do EvilJeffMelee.DrawFrame(memAddress, display, movingLeft, x, y);
		}
		else { if (type = 2)
		{
			do EvilJeffRanged.DrawFrame(memAddress, display, mirrored, x, y);
		}
		else { if (type = 3)
		{
			do Bat.DrawFrame(memAddress, display, mirrored, x, y);
		}}}}
		
		return;
    }



}

